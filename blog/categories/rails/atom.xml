<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Matthew Robertson]]></title>
  <link href="http://matthewrobertson.org/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://matthewrobertson.org/"/>
  <updated>2013-02-19T13:53:39-08:00</updated>
  <id>http://matthewrobertson.org/</id>
  <author>
    <name><![CDATA[Matthew Robertson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing RESS]]></title>
    <link href="http://matthewrobertson.org/blog/2013/02/15/introducing-ress/"/>
    <updated>2013-02-15T01:45:00-08:00</updated>
    <id>http://matthewrobertson.org/blog/2013/02/15/introducing-ress</id>
    <content type="html"><![CDATA[<p>As the diversity of internet connected devices increases, the challenge of building web applications that work well across all of them is becoming both more difficult and more important. Currently, there is a shortage of great ideas in the Rails community about how best to tackle this problem. Most developers lean heavily on one of two approaches: creating a responsive design using CSS media queries or serving a custom UI based on user agent string detection<!-- more -->. But, mobile optimization is a complex problem that involves configuring many aspects of a site, so it is best not to limit yourself to a purely client side or server side approach. I have created <a href="https://github.com/matthewrobertson/ress">a gem</a> that attempts to combine the strengths of client side feature detection, with the flexibility of server side configuration while staying in line with Google’s best practices for SEO and web caching.</p>

<p>Responsive design is becoming dogma for the best way to build mobile friendly websites. While, CSS media queries are great for tweaking the layout of an HTML page to better conform to a variety of screen sizes, they fall short of being the one and only tool needed to provide a truly mobile optimized user experience. There is more to consider than screen size alone: less powerful CPUs, slower network connections and touch oriented interfaces all need to be addressed. When all these limitations are taken into consideration, it is obvious that adding more CSS for the user to download and interpret is not a silver bullet solution.</p>

<p>While less popular, server side solutions tend to be more flexible and capable in terms of the device limitations that can be addressed. The approach of pushing an alternate UI based on the user agent string has been demonstrated in a <a href="http://railscasts.com/episodes/199-mobile-devices">Railscast episode</a> and implemented in the <a href="https://github.com/brendanlim/mobile-fu">Mobile Fu gem</a>. Unfortunately, both of these solutions suffer from some serious flaws. First of all, serving different versions of a web page at the same URL is not RESTful and can have some unwanted consequences (eg caching and SEO). Furthermore, user agent detection can be inaccurate and requires constant maintenance as new devices and software comes to market. From an implementation perspective, the practice of aliasing a mime type and explicitly setting <code>request.format</code> makes it <a href="https://github.com/rails/rails/issues/3855">difficult to share templates</a> between the mobile and canonical versions of the site.</p>

<h2>A Better Solution</h2>

<p>Server side approaches and responsive design each have their own strengths and weaknesses. I have come up with a strategy that attempts to combine the strengths of both and packaged it up as gem called RESS. The gem provides three major features that you can use while optimizing your application for mobile platforms.</p>

<h2>1. Annotation of mobile versions of your app:</h2>

<p>RESS allows you to specify alternate versions of your rails app. Each alternate version has two mandatory attributes: a subdomain under which the version will be served and a media query that describes the type of clients that should be redirected to that site. Once registered, RESS provides a helper method called <code>ress_anotation_tags</code> that should be used to add annotations to the <code>&lt;head&gt;</code> of your document. These tags describe where the alternate versions are located and which devices should be redirected to them.</p>

<p>For example, a typical alternate version for a mobile site might include a tag like this:</p>

<p><code>html
&lt;link rel="alternate" media="only screen and (max-width: 640px)" href="http://m.example.com/page-1" &gt;
</code></p>

<p>The mobile version of the page would also have a link pointing back the canonical version of the app, eg:</p>

<p><code>html
&lt;link rel="canonical" href="http://www.example.com/page-1" &gt;
</code>
These annotations conform to SEO best practices for mobile optimized websites <a href="https://developers.google.com/webmasters/smartphone-sites/details">as documented by Google</a>.</p>

<h2>2. Client side feature detection and redirects:</h2>

<p>As an alternative to redirecting users based on user agent string matching, ress provides a  mechanism to redirect users based on feature detection that is performed on the client side. When a request comes into your site, the javascript included with RESS will parse all of the <code>[rel="alternate"]</code> links in your markup, and evaluate their media queries to determine if there is an alternate version available that matches the client. If there is, the user is redirected to the url for that version. The idea for this style of client side redirection (and much of the implementation) was adapted from the <a href="https://github.com/borismus/device.js">devicejs library</a> by Boris Smus.</p>

<h2>3. Server side progressive enhancement:</h2>

<p>When RESS detects that a request is coming in to one of the alternate versions of your application (via the subdomain), it prepends a path to the list of view paths available for the controller handling the request. Any templates, partials or layouts available in the prepended view path take precedence over those in <code>app/views</code> allowing you to overload individual templates for any version of your site. For example, if I wanted to customize the signup form for the <code>mobile</code> version of my app I would simply need to create a new partial called <code>app/mobile_views/users/new.html.erb</code> with my custom markup. If you do not provide a mobile template, Rails will fall back to <code>app/views</code> as normal.</p>

<p>For smaller tweeks RESS also creates view helpers and controller methods for detecting which version of the app the request has come into. eg:</p>

<p><code>erb
&lt;% if mobile_request? %&gt;
  &lt;%= image_tag 'low-res.png' %&gt;
&lt;% else %&gt;
  &lt;%= image_tag 'high-res.png' %&gt;
&lt;% end %&gt;
</code></p>

<h2>Caveats</h2>

<p>RESS may not be a great for a fit for all applications but, I have done my best to implement the features in an a la carte manner so that you can pick and chose what you want. For example, if you don’t want to suffer the performance costs of client side redirects, you can leave the <code>ress.js</code> file out of your application and do your own server side user agent redirects, but keep the <code>ress_annotation_tags</code> to stay inline with Google’s SEO best practices.</p>

<p>I am keen to hear your thoughts, criticism and feature requests. Feel free to add them to the comments section below, or visit the project <a href="https://github.com/matthewrobertson/ress">on github</a> and create issues.</p>

<h2>References</h2>

<ul>
<li><a href="http://www.html5rocks.com/en/mobile/cross-device/">devicejs</a> <a href="https://github.com/borismus/device.js">github</a></li>
<li><a href="https://developers.google.com/webmasters/smartphone-sites/details">Building Smartphone-Optimized Websites</a></li>
<li><a href="http://www.lukew.com/ff/entry.asp?1392">RESS: Responsive Design + Server Side Components</a> (inspiration for the name RESS)</li>
<li><a href="http://bradfrostweb.com/blog/web/responsive-web-design-missing-the-point/">Response Design Missing the Point</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How To Stop Using Nested Forms]]></title>
    <link href="http://matthewrobertson.org/blog/2012/09/20/decoupling-rails-forms-from-the-database/"/>
    <updated>2012-09-20T01:31:00-07:00</updated>
    <id>http://matthewrobertson.org/blog/2012/09/20/decoupling-rails-forms-from-the-database</id>
    <content type="html"><![CDATA[<p>One issue that caused me a lot of pain on my first few rails projects was the natural coupling that developed between the database and the rest of my application. The “skinny controller, fat model” mantra has been the prevalent in the Rails community since the early days. The problem with this philosophy is that it is only 50% accurate. If you are building good object oriented software, you shouldn’t have a fat anything.<!-- more --> When all of your business logic is encased in ActiveRecord objects, there can be some unfortunate consequences: things become difficult to reason about, it is hard to test objects in isolation and changing the database schema is a painful process that demands updates to many parts of the application.</p>

<p>In my opinion, one of worst offending features of rails is the ability to build nested model forms with <code>fields_for</code> and <code>accepts_nested_attributes_for</code>, as doing so directly couples your view layer to your database schema. Lately, I have been using a very simple technique to prevent this problem that I call building aggregate models.</p>

<h2>An Example</h2>

<p>Consider as an example, an application in which the <code>User</code> model <code>has_one</code> associated <code>Email</code>:</p>

<p>``` ruby
class User &lt; ActiveRecord::Base
  attr_accessible :name, :password, :password_confirmation
  has_one :email
  accepts_nested_attributes_for :email</p>

<p>  # validations etc...
end</p>

<p>class Email &lt; ActiveRecord::Base
  attr_accessible :address, :confirmed
  belongs_to :user</p>

<p>  # validations etc...
end
```</p>

<p>The rails way to handle this association is to build a nested model form via <code>fields_for</code>.</p>

<p>``` erb
&lt;%= form_for @user do |f| %>
  &lt;%= f.text_field :name %>
  &lt;%= f.fields_for @user.email do |p| %></p>

<pre><code>&lt;%= p.email_field :email %&gt;
</code></pre>

<p>  &lt;% end %>
  &lt;%= f.password_field :password %>
  &lt;%= f.password_field :password_confimation %>
&lt;% end%>
```</p>

<p>The obvious problem with this is that it couples the view directly to the database structure. If we decided to make changes to the database schema later, the form will need to be updated. I also find that <code>accepts_nested_attributes_for</code> is awkward to test and the subtleties of the api are difficult to remember and work with (e.g. mass assignment errors, associated validations).</p>

<p>Another option that many rails developers might opt for in this situation is to de-normalize the database and smash the <code>emails</code> and <code>users</code> tables together into one. In this case I decided to keep <code>emails</code> as a separate entity because they are going to have their own attributes (e.g. <code>verified?</code>). I also anticipate a requirement that users will have many emails. While there is <a href="http://www.codinghorror.com/blog/2008/07/maybe-normalizing-isnt-normal.html">a case</a> to be made against normalization in some situations, the fact that it makes your view layer simpler to code is part of it.</p>

<h2>The Solution</h2>

<p>Lately, the approach I have been using in these situations has been to create a class to accept the form data and translate it to the active record layer. In Rails 3.0 the API required by controllers and views was extracted into <a href="http://yehudakatz.com/2010/01/10/activemodel-make-any-ruby-object-feel-like-activerecord/">a set of modules</a> that can be included as needed. This allows us to create an object that is guaranteed to jive with <code>form_for</code> (or any other form gem you may be using) that is completely decoupled from <code>ActiveRecord</code>. To handle the example above, we might end up with something like this:</p>

<p>``` ruby
class Profile
  include ActiveModel::Validations
  include ActiveModel::Conversion
  extend ActiveModel::Naming</p>

<p>  attr_reader :user</p>

<p>  delegate  :name, :name=, :password, :password=, :password_confirmation,</p>

<pre><code>        :password_confirmation=, :persisted?, :id, :to =&gt; :user, 
        :prefix =&gt; false, :allow_nil =&gt; false
</code></pre>

<p>  def initialize(user, email)</p>

<pre><code>@user = user
@email = email
</code></pre>

<p>  end</p>

<p>  def email</p>

<pre><code>@email.address
</code></pre>

<p>  end</p>

<p>  def email=(email_addr)</p>

<pre><code>@email.address = email_addr
</code></pre>

<p>  end</p>

<p>  def attributes=(attributes)</p>

<pre><code>attributes.each { |k, v| self.send("#{k}=", v) }
</code></pre>

<p>  end</p>

<p>  def save!</p>

<pre><code>User.transaction do
  @user.save!
  @email.save!
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby Usage in the controller
def create
  @profile = Profile.new(User.new, Email.new)
  @profile.attributes = params[:profile]
  if @profile.valid?</p>

<pre><code>@profile.save!
redirect_to some_url, :notice =&gt; "Huzzah!"
</code></pre>

<p>  else</p>

<pre><code>render :action =&gt; :new
</code></pre>

<p>  end
end
```</p>

<p>By adding a thin layer of indirection, this pattern reduces the coupling between the view layer and database. There are a few other big wins that come with it as well:</p>

<ul>
<li>the form markup is now as simple as it would be for one model with no associations</li>
<li>we can move business logic out of the <code>ActiveRecord</code> classes and allow them to focus on their persistence responsibility (e.g. hash and salt the password before passing assigning it to <code>User</code>)</li>
<li>we can add a different set of validations at the profile level (e.g. that are only pertinent to new users for example the confirmation of password)</li>
</ul>


<p>Obviously we could enhance the <code>Profile</code> class to make it feel more like an <code>ActiveRecord</code> object (e.g. define <code>update_attributes</code> or a static <code>find_by_user_id</code> method that initializes the model for existing records) but for simple cases there is no need.</p>

<p>As always, this pattern should be used sparingly. Resist the urge to optimize prematurely.</p>
]]></content>
  </entry>
  
</feed>
